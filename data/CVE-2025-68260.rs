use std::sync::{Arc, Mutex};
use std::thread;
use std::cell::UnsafeCell;
// use std::arch::asm;

struct ListNode {
    prev: UnsafeCell<usize>,
    next: UnsafeCell<usize>,
}

unsafe impl Send for ListNode {}
unsafe impl Sync for ListNode {}

impl ListNode {
    fn new() -> Self {
        Self {
            prev: UnsafeCell::new(0),
            next: UnsafeCell::new(0),
        }
    }
}

struct NodeDeath { node: ListNode }

impl NodeDeath {
    fn new() -> Arc<Self> {
        Arc::new(Self {
            node: ListNode::new(),
        })
    }
}

struct NodeInner {
    death_list: Vec<Arc<NodeDeath>>,
}

impl NodeInner {
    fn new() -> Self {
        Self {
            death_list: Vec::new(),
        }
    }
}

fn release_node(node: &Mutex<NodeInner>) {
    // technically, an explicit call to drop is done
    // but this part is the closest i can get without breaking something else
    let death_list_local = {
        let mut inner = node.lock().unwrap();
        std::mem::take(&mut inner.death_list)
        // unsafe { asm!("noop"); }
        // core::ptr::drop_in_place<std::sync::poison::mutex::MutexGuard<test::NodeInner>>
    };

    // unsafe { asm!("noop"); }

    for death in death_list_local {
        unsafe {
            let prev_val = *death.node.prev.get();
            let next_val = *death.node.next.get();
            *death.node.prev.get() = 0;
            *death.node.next.get() = 0;
        }
    }
}

fn main() {
    let node = Arc::new(Mutex::new(NodeInner::new()));
    let death = NodeDeath::new();
    
    {
        let mut n = node.lock().unwrap();
        n.death_list.push(Arc::clone(&death));
    }
    
    let node1 = Arc::clone(&node);
    let node2 = Arc::clone(&node);
    let death2 = Arc::clone(&death);
    
    let t1 = thread::spawn(move || { release_node(&node1); });
    
    let t2 = thread::spawn(move || {
        thread::sleep(std::time::Duration::from_millis(5));
        let _n = node2.lock().unwrap();
        
        unsafe {
            *death2.node.prev.get() = 1;
            *death2.node.next.get() = 1;
        }
    });
    
    t1.join().unwrap();
    t2.join().unwrap();
}
